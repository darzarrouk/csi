

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Fault class &mdash; csi 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="csi 1.0 documentation" href="../index.html"/>
        <link rel="up" title="Classes of faults" href="../faultclasses.html"/>
        <link rel="next" title="fault3D class" href="fault3D.html"/>
        <link rel="prev" title="Classes of faults" href="../faultclasses.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> csi
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../examples.html">Some Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../basictutorial.html">A Basic Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../CSIpublications.html">Citations and CSI Publications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../classes.html">Classes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../mainclass.html">Principal CSI class</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../faultclasses.html">Classes of faults</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">Fault class</a></li>
<li class="toctree-l3"><a class="reference internal" href="fault3D.html">fault3D class</a></li>
<li class="toctree-l3"><a class="reference internal" href="RectangularPatches.html">RectangularPatches class</a></li>
<li class="toctree-l3"><a class="reference internal" href="RectangularPatchesKin.html">RectangularPatchesKin class</a></li>
<li class="toctree-l3"><a class="reference internal" href="TriangularPatches.html">TriangularPatches class</a></li>
<li class="toctree-l3"><a class="reference internal" href="TriangularTents.html">TriangularTents class</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../dataclasses.html">Classes for types of data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../miscclasses.html">Misc. Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tools.html">Useful Tools</a></li>
<li class="toctree-l2"><a class="reference internal" href="../oldclasses.html">Some Untested Classes</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">csi</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../classes.html">Classes</a> &raquo;</li>
        
          <li><a href="../faultclasses.html">Classes of faults</a> &raquo;</li>
        
      <li>Fault class</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/classes/Fault.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="fault-class">
<h1>Fault class<a class="headerlink" href="#fault-class" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="csi.Fault">
<em class="property">class </em><code class="descclassname">csi.</code><code class="descname">Fault</code><span class="sig-paren">(</span><em>name</em>, <em>utmzone=None</em>, <em>ellps='WGS84'</em>, <em>lon0=None</em>, <em>lat0=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault" title="Permalink to this definition">¶</a></dt>
<dd><p>Classes implementing a fault. Parent class to all faults</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>name      : Name of the fault.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first last simple">
<li>utmzone   : UTM zone  (optional, default=None)</li>
<li>lon0      : Longitude of the center of the UTM zone</li>
<li>lat0      : Latitude of the center of the UTM zone</li>
<li>ellps     : ellipsoid (optional, default=’WGS84’)</li>
<li>verbose   : Speak to me (default=True)</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="csi.Fault.addfaults">
<code class="descname">addfaults</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.addfaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Add some other faults to plot with the modeled one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>filename : Name of the file. File is ascii format. First column is longitude. Second column is latitude. Separator between faults is &gt; as in GMT style.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.assembleCd">
<code class="descname">assembleCd</code><span class="sig-paren">(</span><em>datas</em>, <em>add_prediction=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembleCd" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the data covariance matrices that have been built for each 
data structure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>datas : List of data instances or one data instance</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>add_prediction: Precentage of displacement to add to the Cd diagonal to simulate a Cp (dirty version of a prediction error covariance, see Duputel et al 2013, GJI).</li>
<li>verbose       : Talk to me (overwrites self.verbose)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.assembleGFs">
<code class="descname">assembleGFs</code><span class="sig-paren">(</span><em>datas</em>, <em>polys=None</em>, <em>slipdir='sd'</em>, <em>verbose=True</em>, <em>custom=False</em>, <em>computeNormFact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembleGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble the Green’s functions corresponding to the data in datas.
This method allows to specify which transformation is going
to be estimated in the data sets, through the polys argument.</p>
<p>Assembled Green’s function matrix is stored in self.Gassembled</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>datas             : list of data sets. If only one data set is used, can be a data instance only.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first">
<li><p class="first">polys             : None</p>
<blockquote>
<div><ul>
<li><p class="first">For InSAR, Optical, GPS:</p>
<blockquote>
<div><ul class="simple">
<li>1 : estimate a constant offset</li>
<li>3 : estimate z = ax + by + c</li>
<li>4 : estimate z = axy + bx + cy + d</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For GPS only:</p>
<blockquote>
<div><ul class="simple">
<li>full                 : Estimates a rotation, translation and scaling (Helmert transform).</li>
<li>strain               : Estimates the full strain tensor (Rotation, Translation, Internal strain)</li>
<li>strainnorotation     : Estimates the strain tensor and a translation</li>
<li>strainonly           : Estimates the strain tensor</li>
<li>strainnotranslation  : Estimates the strain tensor and a rotation</li>
<li>translation          : Estimates the translation</li>
<li>translationrotation  : Estimates the translation and a rotation</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">slipdir           : Directions of slip to include. Can be any combination of s (strike slip), d (dip slip), t (tensile), c (coupling)</p>
</li>
<li><p class="first">custom            : If True, gets the additional Green’s function rom the dictionary self.G[data.name][‘custom’]</p>
</li>
<li><p class="first">computeNormFact   : True/False to recompute OrbNormalizingFactor</p>
</li>
<li><p class="first">verbose           : Talk to me (overwrites self.verbose)</p>
</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.assembled">
<code class="descname">assembled</code><span class="sig-paren">(</span><em>datas</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembled" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles a data vector for inversion using the list datas
Assembled vector is stored in self.dassembled</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>datas         : list of data objects</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCm">
<code class="descname">buildCm</code><span class="sig-paren">(</span><em>sigma</em>, <em>lam</em>, <em>lam0=None</em>, <em>extra_params=None</em>, <em>lim=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in 
Radiguet et al 2010. We use</p>
<div class="math notranslate">
\[C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\]</div>
<p>extra_params allows to add some diagonal terms and expand the size of 
the matrix, in case the fault object is also hosting the estimation of 
transformation parameters. Model covariance is stored in self.Cm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>sigma         : Amplitude of the correlation.</li>
<li>lam           : Characteristic length scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>lam0          : Normalizing distance. If None, lam0=min(distance between patches)</li>
<li>extra_params  : a list of extra parameters.</li>
<li>lim           : Limit distance parameter (see self.distancePatchToPatch)</li>
<li>verbose       : Talk to me (overwrites self.verrbose)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmGaussian">
<code class="descname">buildCmGaussian</code><span class="sig-paren">(</span><em>sigma</em>, <em>extra_params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a diagonal Cm with sigma values on the diagonal.
Sigma is a list of numbers, as long as you have components of slip (1, 2 or 3).
extra_params allows to add some diagonal terms and expand the size 
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is hold in self.Cm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>sigma         : List of numbers the size of the slip components requried for the modeling</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>extra_params   : a list of extra parameters.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmLaplacian">
<code class="descname">buildCmLaplacian</code><span class="sig-paren">(</span><em>lam</em>, <em>diagFact=None</em>, <em>extra_params=None</em>, <em>sensitivity=True</em>, <em>method='distance'</em>, <em>sensitivityNormalizing=False</em>, <em>irregular=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the Laplacian smoothing with sensitivity (optional) into a model covariance matrix. Description can be found in F. Ortega-Culaciati’s PhD thesis.</p>
<p>extra_params allows to add some diagonal terms and expand the size of the matrix, in case the fault object is also hosting the estimation of transformation parameters.</p>
<p>Model covariance is hold in self.Cm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>lam               : Damping factor (list of size of slipdirections)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>extra_params      : a list of extra parameters.</li>
<li>sensitivity       : Weights the Laplacian by Sensitivity (default True)</li>
<li>irregular         : Only used for rectangular patches. Allows to account for irregular meshing along dip.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmSensitivity">
<code class="descname">buildCmSensitivity</code><span class="sig-paren">(</span><em>sigma</em>, <em>lam</em>, <em>lam0=None</em>, <em>extra_params=None</em>, <em>lim=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmSensitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in Radiguet et al 2010.
We use</p>
<div class="math notranslate">
\[C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\]</div>
<p>Then correlation length is weighted by the sensitivity matrix described in Ortega’s PhD thesis.</p>
<div class="math notranslate">
\[S = diag(G'G)\]</div>
<p>Here, sigma and lambda are lists specifying values for the slip directions. 
extra_params allows to add some diagonal terms and expand the size 
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is stored in self.Cm</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>sigma         : Amplitude of the correlation.</li>
<li>lam           : Characteristic length scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>lam0          : Normalizing distance. If None, lam0=min(distance between patches)</li>
<li>extra_params  : a list of extra parameters.</li>
<li>lim           : Limit distance parameter (see self.distancePatchToPatch)</li>
<li>verbose       : Talk to me (overwrites self.verrbose)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmSlipDirs">
<code class="descname">buildCmSlipDirs</code><span class="sig-paren">(</span><em>sigma</em>, <em>lam</em>, <em>lam0=None</em>, <em>extra_params=None</em>, <em>lim=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmSlipDirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in 
Radiguet et al 2010. Here, Sigma and Lambda are lists specifying 
values for the slip directions. We use</p>
<div class="math notranslate">
\[C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\]</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>sigma         : Amplitude of the correlation.</li>
<li>lam           : Characteristic length scale.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>lam0          : Normalizing distance. If None, lam0=min(distance between patches)</li>
<li>extra_params  : a list of extra parameters.</li>
<li>lim           : Limit distance parameter (see self.distancePatchToPatch)</li>
<li>verbose       : Talk to me (overwrites self.verrbose)</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildGFs">
<code class="descname">buildGFs</code><span class="sig-paren">(</span><em>data</em>, <em>vertical=True</em>, <em>slipdir='sd'</em>, <em>method='homogeneous'</em>, <em>verbose=True</em>, <em>convergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the Green’s function matrix based on the discretized fault.
The Green’s function matrix is stored in a dictionary. 
Each entry of the dictionary is named after the corresponding dataset. 
Each of these entry is a dictionary that contains ‘strikeslip’, ‘dipslip’,
‘tensile’ and/or ‘coupling’</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data          : Data object (gps, insar, optical, …)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</li>
<li>slipdir       : Direction of slip along the patches. Can be any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</li>
<li>method        : Can be ‘okada’ (Okada, 1982, rectangular patches only), ‘meade’ (Meade 2007, triangular patches only), ‘edks’ (Zhao &amp; Rivera, 2002), ‘homogeneous’ (Okada for rectangles, Meade for triangles)</li>
<li>verbose       : Writes stuff to the screen (overwrites self.verbose)</li>
<li>convergence   : If coupling case, needs convergence azimuth and rate [azimuth in deg, rate]</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>TODO: Implement the homogeneous case for the Node-based triangular GFs</p>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.cumdistance">
<code class="descname">cumdistance</code><span class="sig-paren">(</span><em>discretized=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.cumdistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance between the first point of the fault and every 
other point. The distance is cumulative along the fault.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>discretized           : if True, use the discretized fault trace (default False)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>dis                   : Cumulative distance array</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.discretize">
<code class="descname">discretize</code><span class="sig-paren">(</span><em>every=2.0</em>, <em>tol=0.01</em>, <em>fracstep=0.2</em>, <em>xaxis='x'</em>, <em>cum_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the surface fault trace by setting a constant distance between
each point. Pay attention, the fault cannot be exactly a straight 
line north-south. Descretized fault trace is stored in self.xi and 
self.yi</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>every         : Spacing between each point (in km)</li>
<li>tol           : Tolerance in the spacing (in km)</li>
<li>fracstep      : fractional step in the chosen direction for the discretization optimization</li>
<li>xaxis         : Axis for the discretization (can be x or y)</li>
<li>cum_error     : if True, accounts for cumulated error to define the axis bound for the last patch</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.distance2trace">
<code class="descname">distance2trace</code><span class="sig-paren">(</span><em>lon</em>, <em>lat</em>, <em>discretized=False</em>, <em>coord='ll'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.distance2trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance between a point and the trace of a fault.
This is a slow method, so it has been recoded in a few places 
throughout the whole library.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>lon               : Longitude of the point.</li>
<li>lat               : Latitude of the point.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>discretized       : Uses the discretized trace.</li>
<li>coord             : ‘ll’, ‘lonlat’, ‘xy’ or ‘utm’</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>dalong            : Distance to the first point of the fault along the fault</li>
<li>dacross           : Shortest distance between the point and the fault</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.dropPointSources">
<code class="descname">dropPointSources</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.dropPointSources" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops point sources along the fault. Point sources can then be used 
to compute GFs using the EDKS software.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name" colspan="2">The process is controlled by the attributes:</th></tr>
<tr class="field-odd field"><td>&#160;</td><td class="field-body"><ul class="first last simple">
<li>self.sourceSpacing      : Distance between sources</li>
<li>self.sourceArea         : Area of the sources</li>
<li>self.sourceNumber       : Number of sources per patch</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>One needs to set at least one of those three attributes.</p>
<p>Sources are saved in self.plotSources and self.edksSources</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.duplicateFault">
<code class="descname">duplicateFault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.duplicateFault" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a full copy (copy.deepcopy) of the fault object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>fault         : fault object</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.edksGFs">
<code class="descname">edksGFs</code><span class="sig-paren">(</span><em>data</em>, <em>vertical=True</em>, <em>slipdir='sd'</em>, <em>verbose=True</em>, <em>convergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.edksGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the Green’s functions based on the solution by Zhao &amp; Rivera 2002.
The corresponding functions are in the EDKS code that needs to be installed and 
the executables should be found in the directory set by the environment 
variable EDKS_BIN.</p>
<p>A few variables need to be set in before running this method</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Required:</th><td class="field-body"><p class="first">self.kernelsEDKS    : Filename of the EDKS kernels.</p>
</td>
</tr>
<tr class="field-even field"><th class="field-name" colspan="2">One of the Three:</th></tr>
<tr class="field-even field"><td>&#160;</td><td class="field-body"><p class="first">self.sourceSpacing  : Spacing between the sources in each patch.</p>
<p>self.sourceNumber   : Number of sources per patches.</p>
<p>self.sourceArea     : Maximum Area of the sources.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data              : Data object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</li>
<li>slipdir       : Direction of slip along the patches. Any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</li>
<li>verbose       : Writes stuff to the screen (overwrites self.verbose)</li>
<li>convergence   : If coupling case, needs convergence azimuth and rate [azimuth in deg, rate]</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>G             : Dictionary of the built Green’s functions</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.estimateSeismicityRate">
<code class="descname">estimateSeismicityRate</code><span class="sig-paren">(</span><em>earthquake</em>, <em>extra_div=1.0</em>, <em>epsilon=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.estimateSeismicityRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of earthquakes per patches and divides by the area of the patches.
Sets the results in</p>
<blockquote>
<div><ul class="simple">
<li>self.earthquakeInPatch  : Number of earthquakes per patch</li>
<li>self.seismicityRate     : Seismicity rate for this patch</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>earthquake    : seismiclocation object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>extra_div     : Extra divider to get the seismicity rate.</li>
<li>epsilon       : Epsilon value for precision of earthquake location.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.file2trace">
<code class="descname">file2trace</code><span class="sig-paren">(</span><em>filename</em>, <em>utm=False</em>, <em>header=0</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.file2trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the fault trace from a text file (ascii 2 columns)
If utm is False, format is:
Lon Lat 
If utm is True, format is :
X Y (in km)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>filename      : Name of the fault file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>utm           : Specify nature of coordinates</li>
<li>header        : Number of lines to skip at the beginning of the file</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.gaussianSlipSmoothing">
<code class="descname">gaussianSlipSmoothing</code><span class="sig-paren">(</span><em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.gaussianSlipSmoothing" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothes the slip distribution using a Gaussian filter.
Smooth slip distribution is in self.slip</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>length        : Correlation length.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.getindex">
<code class="descname">getindex</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.getindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of a patch.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>p         : Patch from a fault object.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>iout      : index of the patch</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.getslip">
<code class="descname">getslip</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.getslip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slip vector for a patch or tent</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>p         : patch or tent</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>iout      : Index of the patch or tent</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.homogeneousGFs">
<code class="descname">homogeneousGFs</code><span class="sig-paren">(</span><em>data</em>, <em>vertical=True</em>, <em>slipdir='sd'</em>, <em>verbose=True</em>, <em>convergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.homogeneousGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the Green’s functions for a homogeneous half-space.</p>
<p>If your patches are rectangular, Okada’s formulation is used (Okada, 1982)
If your patches are triangular, Meade’s formulation is used (Meade, 2007)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data          : Data object (gps, insar, optical, …)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>vertical      : If True, will produce green’s functions for the vertical displacements in a gps object.</li>
<li>slipdir       : Direction of slip along the patches. Can be any combination of s (strikeslip), d (dipslip), t (tensile) and c (coupling)</li>
<li>verbose       : Writes stuff to the screen (overwrites self.verbose)</li>
<li>convergence   : If coupling case, needs convergence azimuth and rate [azimuth in deg, rate]</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>G             : Dictionary of the built Green’s functions</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.initializeEmptyFault">
<code class="descname">initializeEmptyFault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.initializeEmptyFault" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes what is required for a fault with no patches</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">None</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.initializeslip">
<code class="descname">initializeslip</code><span class="sig-paren">(</span><em>n=None</em>, <em>values=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.initializeslip" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-initializes the fault slip array.
Slip array will be the size of the number of patches/tents times the
3 components of slip (strike-slip, dip slip and tensile).</p>
<p>1st Column is strike slip.
2nd Column is dip slip.
3rd Column is tensile.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>n             : Number of slip values. If None, it’ll take the number of patches.</li>
<li>values        : Can be ‘depth’, ‘strike’, ‘dip’, ‘length’, ‘width’, ‘area’, ‘index’ or a numpy array The array can be of size (n,3) or (n,1)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">None</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.patch2ll">
<code class="descname">patch2ll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.patch2ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes all the patches in self.patch and convert them to lonlat.
Patches are stored in self.patchll</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.patch2xy">
<code class="descname">patch2xy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.patch2xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes all the patches in self.patchll and convert them to xy
Patches are stored in self.patch</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.readPointSourcesFromPickle">
<code class="descname">readPointSourcesFromPickle</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.readPointSourcesFromPickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the point sources for computing Green’s functions with EDKS 
from a pickle file. Sets the sources in self.edksSources</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>filename      : Name of the pickle file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.rotateGFs">
<code class="descname">rotateGFs</code><span class="sig-paren">(</span><em>data</em>, <em>azimuth</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.rotateGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>For the data set data, returns the rotated GFs so that dip slip motion 
is aligned with the azimuth. It uses the Greens functions stored 
in self.G[data.name].</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data          : Name of the data set.</li>
<li>azimuth       : Direction in which to rotate the GFs</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>rotatedGar    : GFs along the azimuth direction</li>
<li>rotatedGrp    : GFs in the direction perpendicular to the azimuth direction</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.saveData">
<code class="descname">saveData</code><span class="sig-paren">(</span><em>dtype='d'</em>, <em>outputDir='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.saveData" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the Data in binary files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>dtype       : ‘d’ for double, ‘f’ for float32</li>
<li>outputDir   : Directory to save binary data</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.saveGFs">
<code class="descname">saveGFs</code><span class="sig-paren">(</span><em>dtype='d'</em>, <em>outputDir='.'</em>, <em>suffix={'coupling': 'Coupling'</em>, <em>'dipslip': 'DS'</em>, <em>'strikeslip': 'SS'</em>, <em>'tensile': 'TS'}</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.saveGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the Green’s functions in different files.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>dtype       : ‘d’ for double, ‘f’ for float32</li>
<li>outputDir   : Directory to save binary data.</li>
<li>suffix      : suffix for GFs name (dictionary)</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setCustomGFs">
<code class="descname">setCustomGFs</code><span class="sig-paren">(</span><em>data</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setCustomGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a custom Green’s Functions matrix in the G dictionary.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data          : Data concerned by the Green’s function</li>
<li>G             : Green’s function matrix</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setGFs">
<code class="descname">setGFs</code><span class="sig-paren">(</span><em>data, strikeslip=[None, None, None], dipslip=[None, None, None], tensile=[None, None, None], coupling=[None, None, None], vertical=False, synthetic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the input Green’s functions matrices into the fault structure.</p>
<p>These GFs are organized in a dictionary structure in self.G
Entries of self.G are the data set names (data.name).
Entries of self.G[data.name] are ‘strikeslip’, ‘dipslip’, ‘tensile’
and/or ‘coupling’</p>
<p>If you provide GPS GFs, those are organised with E, N and U in lines</p>
<p>If you provide Optical GFs, those are organised with E and N in lines</p>
<p>If you provide InSAR GFs, these need to be projected onto the 
LOS direction already.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data          : Data structure</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>strikeslip    : List of matrices of the Strikeslip Green’s functions</li>
<li>dipslip       : List of matrices of the dipslip Green’s functions</li>
<li>tensile       : List of matrices of the tensile Green’s functions</li>
<li>coupling      : List of matrices of the coupling Green’s function</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setGFsFromFile">
<code class="descname">setGFsFromFile</code><span class="sig-paren">(</span><em>data</em>, <em>strikeslip=None</em>, <em>dipslip=None</em>, <em>tensile=None</em>, <em>coupling=None</em>, <em>custom=None</em>, <em>vertical=False</em>, <em>dtype='d'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setGFsFromFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the Green’s functions reading binary files. Be carefull, these have to be in the
good format (i.e. if it is GPS, then GF are E, then N, then U, optional, and
if insar, GF are projected already). Basically, it will work better if you have 
computed the GFs using csi.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>data          : Data object</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>strikeslip    : File containing the Green’s functions for strikeslip related displacements.</li>
<li>dipslip       : File containing the Green’s functions for dipslip related displacements.</li>
<li>tensile       : File containing the Green’s functions for tensile related displacements.</li>
<li>coupling      : File containing the Green’s functions for coupling related displacements.</li>
<li>vertical      : Deal with the UP component (gps: default is false, insar: it will be true anyway).</li>
<li>dtype         : Type of binary data. d for double/float64, f for float32</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setTrace">
<code class="descname">setTrace</code><span class="sig-paren">(</span><em>delta_depth=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the patches to build a fault trace. Fault trace is made of the 
vertices that are shallower than fault top + delta_depth
Fault trace is in self.xf and self.yf</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first last simple">
<li>delta_depth       : Depth extension below top of the fault</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setmu">
<code class="descname">setmu</code><span class="sig-paren">(</span><em>model_file</em>, <em>tents=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setmu" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the shear modulus corresponding to each patch using a model
file from the EDKS software. Shear moduli are set in self.mu</p>
<p>The model file format is as follows:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="24%" />
<col width="24%" />
<col width="24%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">N</th>
<th class="head">F</th>
<th class="head">&#160;</th>
<th class="head">&#160;</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>RHO_1</td>
<td>VP_1</td>
<td>VS_1</td>
<td>TH_1</td>
</tr>
<tr class="row-odd"><td>RHO_2</td>
<td>VP_2</td>
<td>VS_2</td>
<td>TH_2</td>
</tr>
<tr class="row-even"><td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr class="row-odd"><td>RHO_N</td>
<td>VP_N</td>
<td>VS_N</td>
<td>TH_N</td>
</tr>
</tbody>
</table>
<p>where N is the number of layers, F a conversion factor to SI units
RHO_i is the density of the i-th layer
VP_i is the P-wave velocity in the i-th layer
VS_i is the S-wave velocity in the i-th layer
TH_i is the thickness of the i-th layer</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>model_file    : path to model file</li>
<li>tents         : if True, set mu values every point source in patches</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.slipIntegrate">
<code class="descname">slipIntegrate</code><span class="sig-paren">(</span><em>slip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.slipIntegrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrates slip on the patch by simply multiplying slip by the 
patch area. Sets the results in self.volume</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>slip  : Can be strikeslip, dipslip, tensile, coupling or a list/array of floats.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.sumPatches">
<code class="descname">sumPatches</code><span class="sig-paren">(</span><em>iPatches</em>, <em>finalPatch</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.sumPatches" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of indexes of patches, sums the corresponding GFs and 
replace the corresponding patches by the finalPatch in self.patch</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>patches       : List of the patche indexes to sum</li>
<li>finalPatch    : Geometry of the final patch.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>utm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the surface fault trace from Lat/Lon or UTM coordinates
Surface fault trace is stored in self.xf, self.yf (UTM) and
self.lon, self.lat (Lon/lat)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>Lon           : Array/List containing the Lon points.</li>
<li>Lat           : Array/List containing the Lat points.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>utm           : If False, considers x and y are lon/lat, If True, considers x and y are utm in km</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.trace2ll">
<code class="descname">trace2ll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace2ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose the fault trace UTM coordinates into lat/lon.
Lon/Lat coordinates are stored in self.lon and self.lat in degrees</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.trace2xy">
<code class="descname">trace2xy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace2xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose the fault trace lat/lon into the UTM reference.
UTM coordinates are stored in self.xf and self.yf in km</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.writePatchesCenters2File">
<code class="descname">writePatchesCenters2File</code><span class="sig-paren">(</span><em>filename</em>, <em>slip=None</em>, <em>scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writePatchesCenters2File" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the patch center coordinates in an ascii file 
the file format is so that it can by used directly in psxyz (GMT).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>filename      : Name of the file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>slip          : Put the slip as a value for the color. Can be None, strikeslip, dipslip, total, coupling</li>
<li>scale         : Multiply the slip value by a factor.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.writePointSources2Pickle">
<code class="descname">writePointSources2Pickle</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writePointSources2Pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the point sources to a pickle file. 
Always writes the Facet based point sources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>filename      : Name of the pickle file.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.writeTrace2File">
<code class="descname">writeTrace2File</code><span class="sig-paren">(</span><em>filename</em>, <em>ref='lonlat'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writeTrace2File" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the trace to a file. Format is ascii with two columns with
either lon/lat (in degrees) or x/y (utm in km).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Args:</th><td class="field-body"><ul class="first simple">
<li>filename      : Name of the file</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Kwargs:</th><td class="field-body"><ul class="first simple">
<li>ref           : can be lonlat or utm.</li>
</ul>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><ul class="first last simple">
<li>None</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="fault3D.html" class="btn btn-neutral float-right" title="fault3D class" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../faultclasses.html" class="btn btn-neutral" title="Classes of faults" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, R. Jolivet, Z. Duputel, B. Gombert, B. Riel, M. Simons et al..

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>