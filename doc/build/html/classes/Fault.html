
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Fault class &#8212; csi 1.0 documentation</title>
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="fault3D class" href="fault3D.html" />
    <link rel="prev" title="Classes of faults" href="../faultclasses.html" />
   
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">

  </head><body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="fault-class">
<h1>Fault class<a class="headerlink" href="#fault-class" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="csi.Fault">
<em class="property">class </em><code class="descclassname">csi.</code><code class="descname">Fault</code><span class="sig-paren">(</span><em>name</em>, <em>utmzone=None</em>, <em>ellps='WGS84'</em>, <em>lon0=None</em>, <em>lat0=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault" title="Permalink to this definition">¶</a></dt>
<dd><p>Classes implementing a fault. Parent class to all faults</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>name      : Name of the fault.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>utmzone   : UTM zone  (optional, default=None)</li>
<li>lon0      : Longitude of the center of the UTM zone</li>
<li>lat0      : Latitude of the center of the UTM zone</li>
<li>ellps     : ellipsoid (optional, default=’WGS84’)</li>
<li>verbose   : Speak to me (default=True)</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="csi.Fault.addfaults">
<code class="descname">addfaults</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.addfaults" title="Permalink to this definition">¶</a></dt>
<dd><p>Add some other faults to plot with the modeled one.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>filename <span class="classifier-delimiter">:</span> <span class="classifier">Name of the file. File is ascii format.</span></dt>
<dd>First column is longitude. Second column is latitude.
Separator between faults is &gt; as in GMT style.</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.assembleCd">
<code class="descname">assembleCd</code><span class="sig-paren">(</span><em>datas</em>, <em>add_prediction=None</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembleCd" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles the data covariance matrices that have been built for each 
data structure.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>datas         : List of data instances or one data instance</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>add_prediction: Precentage of displacement to add to the Cd </dt>
<dd>diagonal to simulate a Cp (dirty version of 
a prediction error covariance, see Duputel et
al 2013, GJI).</dd>
</dl>
</li>
<li>verbose       : Talk to me (overwrites self.verbose)</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.assembleGFs">
<code class="descname">assembleGFs</code><span class="sig-paren">(</span><em>datas</em>, <em>polys=None</em>, <em>slipdir='sd'</em>, <em>verbose=True</em>, <em>custom=False</em>, <em>computeNormFact=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembleGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Assemble the Green’s functions corresponding to the data in datas.
This method allows to specify which transformation is going
to be estimated in the data sets, through the polys argument.</p>
<p>Assembled Green’s function matrix is stored in self.Gassembled</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>datas <span class="classifier-delimiter">:</span> <span class="classifier">list of data sets. If only one data set is </span></dt>
<dd>used, can be a data instance only.</dd>
</dl>
</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last">
<li><p class="first">polys             : None</p>
<blockquote>
<div><ul>
<li><p class="first">For InSAR, Optical, GPS:</p>
<blockquote>
<div><ul class="simple">
<li>1 : estimate a constant offset</li>
<li>3 : estimate z = ax + by + c</li>
<li>4 : estimate z = axy + bx + cy + d</li>
</ul>
</div></blockquote>
</li>
<li><p class="first">For GPS only:</p>
<blockquote>
<div><ul class="simple">
<li><dl class="first docutils">
<dt>full <span class="classifier-delimiter">:</span> <span class="classifier">Estimates a rotation, </span></dt>
<dd>translation and scaling
(Helmert transform).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>strain <span class="classifier-delimiter">:</span> <span class="classifier">Estimates the full strain </span></dt>
<dd>tensor (Rotation, Translation,
Internal strain)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>strainnorotation <span class="classifier-delimiter">:</span> <span class="classifier">Estimates the strain tensor and a </span></dt>
<dd>translation</dd>
</dl>
</li>
<li>strainonly           : Estimates the strain tensor</li>
<li><dl class="first docutils">
<dt>strainnotranslation <span class="classifier-delimiter">:</span> <span class="classifier">Estimates the strain tensor and a </span></dt>
<dd>rotation</dd>
</dl>
</li>
<li>translation          : Estimates the translation</li>
<li><dl class="first docutils">
<dt>translationrotation <span class="classifier-delimiter">:</span> <span class="classifier">Estimates the translation and a </span></dt>
<dd>rotation</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>slipdir <span class="classifier-delimiter">:</span> <span class="classifier">Directions of slip to include. </span></dt>
<dd><dl class="first last docutils">
<dt>Can be any combination of s, d, t, c or x </dt>
<dd><p class="first last">s: strike slip
d: dip slip
t: tensile
c: coupling</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>custom <span class="classifier-delimiter">:</span> <span class="classifier">If True, gets the additional Green’s function </span></dt>
<dd><p class="first last">from the dictionary self.G[data.name][‘custom’]</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>computeNormFact <span class="classifier-delimiter">:</span> <span class="classifier">bool</span></dt>
<dd><p class="first last">if True, compute new OrbNormalizingFactor
if False, uses parameters in self.OrbNormalizingFactor</p>
</dd>
</dl>
</li>
<li><p class="first">verbose           : Talk to me (overwrites self.verbose)</p>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.assembled">
<code class="descname">assembled</code><span class="sig-paren">(</span><em>datas</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.assembled" title="Permalink to this definition">¶</a></dt>
<dd><p>Assembles a data vector for inversion using the list datas
Assembled vector is stored in self.dassembled</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>datas         : list of data objects</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCm">
<code class="descname">buildCm</code><span class="sig-paren">(</span><em>sigma</em>, <em>lam</em>, <em>lam0=None</em>, <em>extra_params=None</em>, <em>lim=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCm" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in 
Radiguet et al 2010. We use</p>
<div class="math notranslate">
\[C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\]</div>
<p>extra_params allows to add some diagonal terms and expand the size of 
the matrix, in case the fault object is also hosting the estimation of 
transformation parameters. Model covariance is stored in self.Cm</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>sigma         : Amplitude of the correlation.</li>
<li>lam           : Characteristic length scale.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>lam0 <span class="classifier-delimiter">:</span> <span class="classifier">Normalizing distance </span></dt>
<dd>if None, lam0=min(distance between patches)</dd>
</dl>
</li>
<li>extra_params  : a list of extra parameters.</li>
<li>lim           : Limit distance parameter (see self.distancePatchToPatch)</li>
<li>verbose       : Talk to me (overwrites self.verrbose)</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmGaussian">
<code class="descname">buildCmGaussian</code><span class="sig-paren">(</span><em>sigma</em>, <em>extra_params=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmGaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a diagonal Cm with sigma values on the diagonal.
Sigma is a list of numbers, as long as you have components of slip (1, 2 or 3).
extra_params allows to add some diagonal terms and expand the size 
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is hold in self.Cm</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>sigma <span class="classifier-delimiter">:</span> <span class="classifier">List of numbers the size of the slip components</span></dt>
<dd>requried for the modeling</dd>
</dl>
</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>extra_params   : a list of extra parameters.</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmLaplacian">
<code class="descname">buildCmLaplacian</code><span class="sig-paren">(</span><em>lam</em>, <em>diagFact=None</em>, <em>extra_params=None</em>, <em>sensitivity=True</em>, <em>method='distance'</em>, <em>sensitivityNormalizing=False</em>, <em>irregular=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmLaplacian" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the Laplacian smoothing with sensitivity (optional) into
a model covariance matrix. Description can be found in 
F. Ortega-Culaciati’s PhD thesis.</p>
<p>extra_params allows to add some diagonal terms and expand the size 
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is hold in self.Cm</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>lam               : Damping factor (list of size of slipdirections)</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>extra_params   : a list of extra parameters.</li>
<li>sensitivity       : Weights the Laplacian by Sensitivity (default True)</li>
<li><dl class="first docutils">
<dt>irregular <span class="classifier-delimiter">:</span> <span class="classifier">Only used for rectangular patches. Allows to account </span></dt>
<dd>for irregular meshing along dip.</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmSensitivity">
<code class="descname">buildCmSensitivity</code><span class="sig-paren">(</span><em>sigma</em>, <em>lam</em>, <em>lam0=None</em>, <em>extra_params=None</em>, <em>lim=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmSensitivity" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in Radiguet et al 2010.
We use</p>
<div class="math notranslate">
\[C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\]</div>
<p>Then correlation length is weighted by the sensitivity matrix described in Ortega’s PhD thesis.</p>
<div class="math notranslate">
\[S = diag(G'G)\]</div>
<p>Here, sigma and lambda are lists specifying values for the slip directions. 
extra_params allows to add some diagonal terms and expand the size 
of the matrix, in case the fault object is also hosting the estimation
of transformation parameters.</p>
<p>Model covariance is stored in self.Cm</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>sigma         : Amplitude of the correlation.</li>
<li>lam           : Characteristic length scale.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>lam0 <span class="classifier-delimiter">:</span> <span class="classifier">Normalizing distance </span></dt>
<dd>if None, lam0=min(distance between patches)</dd>
</dl>
</li>
<li>extra_params  : a list of extra parameters.</li>
<li>lim           : Limit distance parameter (see self.distancePatchToPatch)</li>
<li>verbose       : Talk to me (overwrites self.verrbose)</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildCmSlipDirs">
<code class="descname">buildCmSlipDirs</code><span class="sig-paren">(</span><em>sigma</em>, <em>lam</em>, <em>lam0=None</em>, <em>extra_params=None</em>, <em>lim=None</em>, <em>verbose=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildCmSlipDirs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds a model covariance matrix using the equation described in 
Radiguet et al 2010. Here, Sigma and Lambda are lists specifying 
values for the slip directions. We use</p>
<div class="math notranslate">
\[C_m(i,j) = \frac{\sigma\lambda_0}{\lambda}^2 e^{-\frac{||i,j||_2}{\lambda}}\]</div>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>sigma         : Amplitude of the correlation.</li>
<li>lam           : Characteristic length scale.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>lam0 <span class="classifier-delimiter">:</span> <span class="classifier">Normalizing distance </span></dt>
<dd>if None, lam0=min(distance between patches)</dd>
</dl>
</li>
<li>extra_params  : a list of extra parameters.</li>
<li>lim           : Limit distance parameter (see self.distancePatchToPatch)</li>
<li>verbose       : Talk to me (overwrites self.verrbose)</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.buildGFs">
<code class="descname">buildGFs</code><span class="sig-paren">(</span><em>data</em>, <em>vertical=True</em>, <em>slipdir='sd'</em>, <em>method='homogeneous'</em>, <em>verbose=True</em>, <em>convergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.buildGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the Green’s function matrix based on the discretized fault.
The Green’s function matrix is stored in a dictionary. 
Each entry of the dictionary is named after the corresponding dataset. 
Each of these entry is a dictionary that contains ‘strikeslip’, ‘dipslip’,
‘tensile’ and/or ‘coupling’</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data          : Data object (gps, insar, optical, …)</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>vertical <span class="classifier-delimiter">:</span> <span class="classifier">If True, will produce green’s functions for</span></dt>
<dd>the vertical displacements in a gps object.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>slipdir <span class="classifier-delimiter">:</span> <span class="classifier">Direction of slip along the patches. </span></dt>
<dd>Can be any combination of s (strikeslip), 
d (dipslip), t (tensile) and c (coupling)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>method <span class="classifier-delimiter">:</span> <span class="classifier">Can be okada (Okada, 1982) (rectangular patches only)</span></dt>
<dd>meade (Meade 2007) (triangular patches only)
edks (Zhao &amp; Rivera, 2002) 
homogeneous (Okada for rectangles, Meade for triangles)</dd>
</dl>
</li>
<li>verbose       : Writes stuff to the screen (overwrites self.verbose)</li>
<li><dl class="first docutils">
<dt>convergence <span class="classifier-delimiter">:</span> <span class="classifier">If coupling case, needs convergence azimuth </span></dt>
<dd>and rate [azimuth in deg, rate]</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
<p>TODO: Implement the homogeneous case for the Node-based triangular GFs</p>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.cumdistance">
<code class="descname">cumdistance</code><span class="sig-paren">(</span><em>discretized=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.cumdistance" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance between the first point of the fault and every 
other point. The distance is cumulative along the fault.</p>
<dl class="docutils">
<dt>Args:   </dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>discretized <span class="classifier-delimiter">:</span> <span class="classifier">if True, use the discretized fault trace </span></dt>
<dd>(default False)</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>dis                   : Cumulative distance array</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.discretize">
<code class="descname">discretize</code><span class="sig-paren">(</span><em>every=2.0</em>, <em>tol=0.01</em>, <em>fracstep=0.2</em>, <em>xaxis='x'</em>, <em>cum_error=True</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.discretize" title="Permalink to this definition">¶</a></dt>
<dd><p>Refine the surface fault trace by setting a constant distance between
each point. Pay attention, the fault cannot be exactly a straight 
line north-south. Descretized fault trace is stored in self.xi and 
self.yi</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>every         : Spacing between each point (in km)</li>
<li>tol           : Tolerance in the spacing (in km)</li>
<li><dl class="first docutils">
<dt>fracstep <span class="classifier-delimiter">:</span> <span class="classifier">fractional step in the chosen direction </span></dt>
<dd>for the discretization optimization</dd>
</dl>
</li>
<li>xaxis         : Axis for the discretization (can be x or y)</li>
<li><dl class="first docutils">
<dt>cum_error <span class="classifier-delimiter">:</span> <span class="classifier">if True, accounts for cumulated error to define </span></dt>
<dd>the axis bound for the last patch</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.distance2trace">
<code class="descname">distance2trace</code><span class="sig-paren">(</span><em>lon</em>, <em>lat</em>, <em>discretized=False</em>, <em>coord='ll'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.distance2trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the distance between a point and the trace of a fault.
This is a slow method, so it has been recoded in a few places 
throughout the whole library.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>lon               : Longitude of the point.</li>
<li>lat               : Latitude of the point.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>discretized       : Uses the discretized trace.</li>
<li><dl class="first docutils">
<dt>coord <span class="classifier-delimiter">:</span> <span class="classifier">If ll or lonlat –&gt; input in degree</span></dt>
<dd>If ‘xy’ or ‘utm’    –&gt; input in km</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>dalong            : Distance to the first point of the fault along the fault</li>
<li>dacross           : Shortest distance between the point and the fault</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.dropPointSources">
<code class="descname">dropPointSources</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.dropPointSources" title="Permalink to this definition">¶</a></dt>
<dd><p>Drops point sources along the fault. Point sources can then be used 
to compute GFs using the EDKS software.</p>
<dl class="docutils">
<dt>The process is controlled by the attributes:</dt>
<dd><ul class="first last simple">
<li>self.sourceSpacing      : Distance between sources</li>
<li>self.sourceArea         : Area of the sources</li>
<li>self.sourceNumber       : Number of sources per patch</li>
</ul>
</dd>
</dl>
<p>One needs to set at least one of those three attributes.</p>
<p>Sources are saved in self.plotSources and self.edksSources</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.duplicateFault">
<code class="descname">duplicateFault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.duplicateFault" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a full copy (copy.deepcopy) of the fault object.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>fault         : fault object</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.edksGFs">
<code class="descname">edksGFs</code><span class="sig-paren">(</span><em>data</em>, <em>vertical=True</em>, <em>slipdir='sd'</em>, <em>verbose=True</em>, <em>convergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.edksGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the Green’s functions based on the solution by Zhao &amp; Rivera 2002.
The corresponding functions are in the EDKS code that needs to be installed and 
the executables should be found in the directory set by the environment 
variable EDKS_BIN.</p>
<p>A few variables need to be set in before running this method</p>
<blockquote>
<div><dl class="docutils">
<dt>Required:</dt>
<dd>self.kernelsEDKS    : Filename of the EDKS kernels.</dd>
<dt>One of the Three:</dt>
<dd>self.sourceSpacing  : Spacing between the sources in each patch.
self.sourceNumber   : Number of sources per patches.
self.sourceArea     : Maximum Area of the sources.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data              : Data object</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>vertical <span class="classifier-delimiter">:</span> <span class="classifier">If True, will produce green’s functions for</span></dt>
<dd>the vertical displacements in a gps object.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>slipdir <span class="classifier-delimiter">:</span> <span class="classifier">Direction of slip along the patches. </span></dt>
<dd><dl class="first last docutils">
<dt>Can be any combination of s (strikeslip), </dt>
<dd>d (dipslip), 
t (tensile) and 
c (coupling)</dd>
</dl>
</dd>
</dl>
</li>
<li>verbose       : Writes stuff to the screen (overwrites self.verbose)</li>
<li><dl class="first docutils">
<dt>convergence <span class="classifier-delimiter">:</span> <span class="classifier">If coupling case, needs convergence azimuth </span></dt>
<dd>and rate [azimuth in deg, rate]</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>G             : Dictionary of the built Green’s functions</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.estimateSeismicityRate">
<code class="descname">estimateSeismicityRate</code><span class="sig-paren">(</span><em>earthquake</em>, <em>extra_div=1.0</em>, <em>epsilon=1e-05</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.estimateSeismicityRate" title="Permalink to this definition">¶</a></dt>
<dd><p>Counts the number of earthquakes per patches and divides by the area of the patches.
Sets the results in</p>
<blockquote>
<div><ul class="simple">
<li>self.earthquakeInPatch  : Number of earthquakes per patch</li>
<li>self.seismicityRate     : Seismicity rate for this patch</li>
</ul>
</div></blockquote>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>earthquake    : seismiclocation object</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>extra_div     : Extra divider to get the seismicity rate.</li>
<li>epsilon       : Epsilon value for precision of earthquake location.</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.file2trace">
<code class="descname">file2trace</code><span class="sig-paren">(</span><em>filename</em>, <em>utm=False</em>, <em>header=0</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.file2trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the fault trace from a text file (ascii 2 columns)
If utm is False, format is:
Lon Lat 
If utm is True, format is :
X Y (in km)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>filename      : Name of the fault file.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>utm           : Specify nature of coordinates</li>
<li><dl class="first docutils">
<dt>header <span class="classifier-delimiter">:</span> <span class="classifier">Number of lines to skip </span></dt>
<dd>at the beginning of the file</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.gaussianSlipSmoothing">
<code class="descname">gaussianSlipSmoothing</code><span class="sig-paren">(</span><em>length</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.gaussianSlipSmoothing" title="Permalink to this definition">¶</a></dt>
<dd><p>Smoothes the slip distribution using a Gaussian filter.
Smooth slip distribution is in self.slip</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>length        : Correlation length.</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.getindex">
<code class="descname">getindex</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.getindex" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index of a patch.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>p         : Patch from a fault object.</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>iout      : index of the patch</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.getslip">
<code class="descname">getslip</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.getslip" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the slip vector for a patch or tent</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>p         : patch or tent</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>iout      : Index of the patch or tent</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.homogeneousGFs">
<code class="descname">homogeneousGFs</code><span class="sig-paren">(</span><em>data</em>, <em>vertical=True</em>, <em>slipdir='sd'</em>, <em>verbose=True</em>, <em>convergence=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.homogeneousGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Builds the Green’s functions for a homogeneous half-space.</p>
<p>If your patches are rectangular, Okada’s formulation is used (Okada, 1982)
If your patches are triangular, Meade’s formulation is used (Meade, 2007)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data          : Data object (gps, insar, optical, …)</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>vertical <span class="classifier-delimiter">:</span> <span class="classifier">If True, will produce green’s functions for</span></dt>
<dd>the vertical displacements in a gps object.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>slipdir <span class="classifier-delimiter">:</span> <span class="classifier">Direction of slip along the patches. </span></dt>
<dd><dl class="first last docutils">
<dt>Can be any combination of s (strikeslip), </dt>
<dd>d (dipslip), 
t (tensile) and 
c (coupling)</dd>
</dl>
</dd>
</dl>
</li>
<li>verbose       : Writes stuff to the screen (overwrites self.verbose)</li>
<li><dl class="first docutils">
<dt>convergence <span class="classifier-delimiter">:</span> <span class="classifier">If coupling case, needs convergence azimuth </span></dt>
<dd>and rate [azimuth in deg, rate]</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>G             : Dictionary of the built Green’s functions</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.initializeEmptyFault">
<code class="descname">initializeEmptyFault</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.initializeEmptyFault" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes what is required for a fault with no patches</p>
<p>Returns: None</p>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.initializeslip">
<code class="descname">initializeslip</code><span class="sig-paren">(</span><em>n=None</em>, <em>values=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.initializeslip" title="Permalink to this definition">¶</a></dt>
<dd><p>Re-initializes the fault slip array.
Slip array will be the size of the number of patches/tents times the
3 components of slip (strike-slip, dip slip and tensile).</p>
<p>1st Column is strike slip.
2nd Column is dip slip.
3rd Column is tensile.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>n <span class="classifier-delimiter">:</span> <span class="classifier">Number of slip values. If None, it’ll take the </span></dt>
<dd>number of patches.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>values <span class="classifier-delimiter">:</span> <span class="classifier">Can be ‘depth’, ‘strike’, ‘dip’, ‘length’, </span></dt>
<dd>‘width’, ‘area’, ‘index’ or a numpy array
The array can be of size (n,3) or (n,1)</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd>None</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.patch2ll">
<code class="descname">patch2ll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.patch2ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes all the patches in self.patch and convert them to lonlat.
Patches are stored in self.patchll</p>
<dl class="docutils">
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.patch2xy">
<code class="descname">patch2xy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.patch2xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes all the patches in self.patchll and convert them to xy
Patches are stored in self.patch</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.readPointSourcesFromPickle">
<code class="descname">readPointSourcesFromPickle</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.readPointSourcesFromPickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the point sources for computing Green’s functions with EDKS 
from a pickle file. Sets the sources in self.edksSources</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>filename      : Name of the pickle file</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.rotateGFs">
<code class="descname">rotateGFs</code><span class="sig-paren">(</span><em>data</em>, <em>azimuth</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.rotateGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>For the data set data, returns the rotated GFs so that dip slip motion 
is aligned with the azimuth. It uses the Greens functions stored 
in self.G[data.name].</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data          : Name of the data set.</li>
<li>azimuth       : Direction in which to rotate the GFs</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>rotatedGar    : GFs along the azimuth direction</li>
<li><dl class="first docutils">
<dt>rotatedGrp <span class="classifier-delimiter">:</span> <span class="classifier">GFs in the direction perpendicular to the </span></dt>
<dd>azimuth direction</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.saveData">
<code class="descname">saveData</code><span class="sig-paren">(</span><em>dtype='d'</em>, <em>outputDir='.'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.saveData" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the Data in binary files.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">Format of the binary data saved</span></dt>
<dd>‘d’ for double
‘f’ for float32</dd>
</dl>
</li>
<li>outputDir   : Directory to save binary data</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.saveGFs">
<code class="descname">saveGFs</code><span class="sig-paren">(</span><em>dtype='d'</em>, <em>outputDir='.'</em>, <em>suffix={'coupling': 'Coupling'</em>, <em>'dipslip': 'DS'</em>, <em>'strikeslip': 'SS'</em>, <em>'tensile': 'TS'}</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.saveGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves the Green’s functions in different files.</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">Format of the binary data saved </span></dt>
<dd>‘d’ for double
‘f’ for float32</dd>
</dl>
</li>
<li>outputDir   : Directory to save binary data.</li>
<li>suffix      : suffix for GFs name (dictionary)</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setCustomGFs">
<code class="descname">setCustomGFs</code><span class="sig-paren">(</span><em>data</em>, <em>G</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setCustomGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets a custom Green’s Functions matrix in the G dictionary.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data          : Data concerned by the Green’s function</li>
<li>G             : Green’s function matrix</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setGFs">
<code class="descname">setGFs</code><span class="sig-paren">(</span><em>data, strikeslip=[None, None, None], dipslip=[None, None, None], tensile=[None, None, None], coupling=[None, None, None], vertical=False, synthetic=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setGFs" title="Permalink to this definition">¶</a></dt>
<dd><p>Stores the input Green’s functions matrices into the fault structure.</p>
<p>These GFs are organized in a dictionary structure in self.G
Entries of self.G are the data set names (data.name).
Entries of self.G[data.name] are ‘strikeslip’, ‘dipslip’, ‘tensile’
and/or ‘coupling’</p>
<p>If you provide GPS GFs, those are organised with E, N and U in lines</p>
<p>If you provide Optical GFs, those are organised with E and N in lines</p>
<p>If you provide InSAR GFs, these need to be projected onto the 
LOS direction already.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data          : Data structure</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>strikeslip <span class="classifier-delimiter">:</span> <span class="classifier">List of matrices of the Strikeslip </span></dt>
<dd>Green’s functions</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dipslip <span class="classifier-delimiter">:</span> <span class="classifier">List of matrices of the dipslip </span></dt>
<dd>Green’s functions</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tensile <span class="classifier-delimiter">:</span> <span class="classifier">List of matrices of the tensile Green’s </span></dt>
<dd>functions</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coupling <span class="classifier-delimiter">:</span> <span class="classifier">List of matrices of the coupling Green’s </span></dt>
<dd>function</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setGFsFromFile">
<code class="descname">setGFsFromFile</code><span class="sig-paren">(</span><em>data</em>, <em>strikeslip=None</em>, <em>dipslip=None</em>, <em>tensile=None</em>, <em>coupling=None</em>, <em>custom=None</em>, <em>vertical=False</em>, <em>dtype='d'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setGFsFromFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the Green’s functions reading binary files. Be carefull, these have to be in the
good format (i.e. if it is GPS, then GF are E, then N, then U, optional, and
if insar, GF are projected already). Basically, it will work better if you have 
computed the GFs using csi.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>data          : Data object</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>strikeslip <span class="classifier-delimiter">:</span> <span class="classifier">File containing the Green’s functions for </span></dt>
<dd>strikeslip related displacements.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dipslip <span class="classifier-delimiter">:</span> <span class="classifier">File containing the Green’s functions for </span></dt>
<dd>dipslip related displacements.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>tensile <span class="classifier-delimiter">:</span> <span class="classifier">File containing the Green’s functions for </span></dt>
<dd>tensile related displacements.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>coupling <span class="classifier-delimiter">:</span> <span class="classifier">File containing the Green’s functions for </span></dt>
<dd>coupling related displacements.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>vertical <span class="classifier-delimiter">:</span> <span class="classifier">Deal with the UP component (gps: default is false,</span></dt>
<dd>insar: it will be true anyway).</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>dtype <span class="classifier-delimiter">:</span> <span class="classifier">Type of binary data.</span></dt>
<dd>d for double/float64
f for float32</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setTrace">
<code class="descname">setTrace</code><span class="sig-paren">(</span><em>delta_depth=0.0</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setTrace" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses the patches to build a fault trace. Fault trace is made of the 
vertices that are shallower than fault top + delta_depth
Fault trace is in self.xf and self.yf</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>delta_depth       : Depth extension below top of the fault</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.setmu">
<code class="descname">setmu</code><span class="sig-paren">(</span><em>model_file</em>, <em>tents=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.setmu" title="Permalink to this definition">¶</a></dt>
<dd><p>Gets the shear modulus corresponding to each patch using a model
file from the EDKS software. Shear moduli are set in self.mu</p>
<p>The model file format is as follows:        
N F
RHO_1 VP_1 VS_1 TH_1
RHO_2 VP_2 VS_2 TH_2
…
RHO_N VP_N VS_N TH_N</p>
<p>where N is the number of layers, F a conversion factor to SI units
RHO_i is the density of the i-th layer
VP_i is the P-wave velocity in the i-th layer
VS_i is the S-wave velocity in the i-th layer
TH_i is the thickness of the i-th layer</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>model_file    : path to model file</li>
<li>tents         : if True, set mu values every point source in patches</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.slipIntegrate">
<code class="descname">slipIntegrate</code><span class="sig-paren">(</span><em>slip=None</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.slipIntegrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrates slip on the patch by simply multiplying slip by the 
patch area. Sets the results in self.volume</p>
<dl class="docutils">
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>slip <span class="classifier-delimiter">:</span> <span class="classifier">Can be strikeslip, dipslip, tensile, coupling or</span></dt>
<dd>a list/array of floats.</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.sumPatches">
<code class="descname">sumPatches</code><span class="sig-paren">(</span><em>iPatches</em>, <em>finalPatch</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.sumPatches" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of indexes of patches, sums the corresponding GFs and 
replace the corresponding patches by the finalPatch in self.patch</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>patches       : List of the patche indexes to sum</li>
<li>finalPatch    : Geometry of the final patch.</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.trace">
<code class="descname">trace</code><span class="sig-paren">(</span><em>x</em>, <em>y</em>, <em>utm=False</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the surface fault trace from Lat/Lon or UTM coordinates
Surface fault trace is stored in self.xf, self.yf (UTM) and
self.lon, self.lat (Lon/lat)</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>Lon           : Array/List containing the Lon points.</li>
<li>Lat           : Array/List containing the Lat points.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>utm <span class="classifier-delimiter">:</span> <span class="classifier">If False, considers x and y are lon/lat</span></dt>
<dd>If True, considers x and y are utm in km</dd>
</dl>
</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.trace2ll">
<code class="descname">trace2ll</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace2ll" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose the fault trace UTM coordinates into lat/lon.
Lon/Lat coordinates are stored in self.lon and self.lat in degrees</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.trace2xy">
<code class="descname">trace2xy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.trace2xy" title="Permalink to this definition">¶</a></dt>
<dd><p>Transpose the fault trace lat/lon into the UTM reference.
UTM coordinates are stored in self.xf and self.yf in km</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.writePatchesCenters2File">
<code class="descname">writePatchesCenters2File</code><span class="sig-paren">(</span><em>filename</em>, <em>slip=None</em>, <em>scale=1.0</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writePatchesCenters2File" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the patch center coordinates in an ascii file 
the file format is so that it can by used directly in psxyz (GMT).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>filename      : Name of the file.</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>slip <span class="classifier-delimiter">:</span> <span class="classifier">Put the slip as a value for the color.</span></dt>
<dd>Can be None, strikeslip, dipslip, total, coupling</dd>
</dl>
</li>
<li>scale         : Multiply the slip value by a factor.</li>
</ul>
</dd>
<dt>Retunrs:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.writePointSources2Pickle">
<code class="descname">writePointSources2Pickle</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writePointSources2Pickle" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the point sources to a pickle file. 
Always writes the Facet based point sources.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>filename      : Name of the pickle file.</li>
</ul>
</dd>
<dt>Returns:</dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="csi.Fault.writeTrace2File">
<code class="descname">writeTrace2File</code><span class="sig-paren">(</span><em>filename</em>, <em>ref='lonlat'</em><span class="sig-paren">)</span><a class="headerlink" href="#csi.Fault.writeTrace2File" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes the trace to a file. Format is ascii with two columns with
either lon/lat (in degrees) or x/y (utm in km).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><ul class="first last simple">
<li>filename      : Name of the file</li>
</ul>
</dd>
<dt>Kwargs:</dt>
<dd><ul class="first last simple">
<li>ref           : can be lonlat or utm.</li>
</ul>
</dd>
<dt>Returns:    </dt>
<dd><ul class="first last simple">
<li>None</li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../classes.html">Classes</a><ul>
  <li><a href="../faultclasses.html">Classes of faults</a><ul>
      <li>Previous: <a href="../faultclasses.html" title="previous chapter">Classes of faults</a></li>
      <li>Next: <a href="fault3D.html" title="next chapter">fault3D class</a></li>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/classes/Fault.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2018, R. Jolivet, Z. Duputel, B. Gombert, B. Riel, M. Simons et al..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.7.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.6</a>
      
      |
      <a href="../_sources/classes/Fault.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>